<!DOCTYPE html><html><head><meta charset="UTF-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times,
              'Times New Roman', serif,
              "Hiragino Sans GB", "STXihei", "微软雅黑";
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp {
  color: #000;
  font-family: monospace;
  font-size: 0.88em;
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC;
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px;}
pre code { border: 0px !important; }
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}</style></head><body><h1 id="cs290b-hw3">CS290B-HW3</h1>

<p>ASSIGNMENT 3: A DIVIDE-AND-CONQUER API</p>

<p>by Karl Lopker</p>

<h2 id="paper-summary-cx-a-scalable-robust-network-for-parallel">Paper Summary: CX: A Scalable, Robust Network for Parallel</h2>

<p>As commodity computers become cheaper, new supercomputers are becoming scarce. This paper introduces an architecture designed to abstract the use of computer clusters for programmers. The architecture is called CX, or Computation eXchange. The goal is to soak up unused CPU cycles on networked computers through a simple API. The paper also describes the CX architecture along with potential performance constraints and fault tolerance considerations.</p>

<p>In order to take cluster computing mainstream, the paper proposes an API for programmers. This API abstracts the underlying system provided the programmer respects the two defined models. The first model is the Computational Model. In the Computational Model, the programmer must be aware that tasks can be stopped at any time so they must execute quickly with little blocking time. In this respect it is best to adopt the Clik paradigm such that all threads are non blocking. The second model is the Programming Model. In the Programming Model the programmer must be aware of communication overhead. When putting tasks on the task server the programmer must be careful with the number of tasks used. The paper suggests batch sending tasks so that one connection can be used. These two models can be at odds with each other however using parallel techniques, tasks can both be large enough for communication and also quick to compute.</p>

<p>The programmer has two methods to interact with the task server: storeTask and storeResult. The storeTask method allows the programmer to add new tasks to the task server. These tasks may have dependencies on other tasks and will be put into a wait queue until they are ready. The storeResult method is used to signal that a task has a usable value to either return to a client or to use as another task's dependency. Both methods allow for sending their arguments in bulk for communication efficiency.</p>

<p>The architecture of CX has several requirements. Operations dealing with scheduling must be as quick as possible. This means a low time complexity, but also memory efficient. Also, the architecture must be scalable. The system must be able to add and subtract both computers and spaces dynamically. This dynamic scaling allows for responsive fault tolerance that can recover without special intervention. Finally, after a failure the system must be able to reconfigure itself to prepare for another. The CX architecture achieves these requirements by using isolated clusters. These clusters each contain its own task server and producers. The producers only communicate with their task server, the task server communicates with its producers and other task servers.</p>

<p>The isolated clusters are configured into a 'fat tree' with two root nodes. Task servers will steal work from the cluster above it and give work extra to the cluster below. To deal with fault tolerance each cluster knows about two clusters above it. This way if the main cluster were to die they can simply switch over to the secondary one. Clusters in the same level and branch share their task results so that completed is not lost in a crash. When a cluster goes down one of the leaf clusters will take its place.</p>

<p>In conclusion, this paper describes a scalable, fault tolerant way to distribute compute tasks. Using this type of system will become more popular in the future so this foundation must be solid. This paper details a concrete API for programmers, but also provides considerations for its use.</p>
</body>
